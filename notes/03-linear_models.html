<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3. Linear Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="03-linear_models_files/libs/clipboard/clipboard.min.js"></script>
<script src="03-linear_models_files/libs/quarto-html/quarto.js"></script>
<script src="03-linear_models_files/libs/quarto-html/popper.min.js"></script>
<script src="03-linear_models_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="03-linear_models_files/libs/quarto-html/anchor.min.js"></script>
<link href="03-linear_models_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="03-linear_models_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="03-linear_models_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="03-linear_models_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="03-linear_models_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="03-linear_models.html"><i class="bi bi-file-slides"></i>RevealJS</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">3. Linear Models</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<ul>
<li><p>motivating case study</p></li>
<li><p>linear models</p></li>
<li><p>sparse linear models</p></li>
<li><p>bias variance trade-off</p></li>
</ul>
<hr>
<section id="reading" class="level2">
<h2 class="anchored" data-anchor-id="reading">Reading</h2>
<ul>
<li><strong>Sections 10.4 - 10.6.</strong>. Yu, B., &amp; Barter, R. L. (2024). Veridical data science. London, England: MIT Press. https://vdsbook.com/10-ls_continued</li>
</ul>
<hr>
<section id="learning-outcomes" class="level3">
<h3 class="anchored" data-anchor-id="learning-outcomes">Learning outcomes</h3>
<ol type="1">
<li>Describe the theoretical foundation of intrinsically interpretable models like sparse regression, gaussian processes, and classification and regression trees, and apply them to realistic case studies with appropriate validation checks.</li>
<li>Compare the competing definitions of interpretable machine learning, the motivations behind them, and metrics that can be used to quantify whether they have been met.</li>
</ol>
<hr>
</section>
<section id="drug-response-prediction" class="level3">
<h3 class="anchored" data-anchor-id="drug-response-prediction">Drug response prediction</h3>
<ul>
<li><p>Patients with the same diagnosed cancer often respond very differently to the same drug. How can we figure out which drugs any particular patient will respond to?</p></li>
<li><p>If we imagine <code>drug effectiveness = f(gene activity)</code>, then one approach is to measure activity of genetic pathways in biopsies of that patient’s cancer tissue.</p></li>
<li><p>The most important features in that model can be used to stratify patients into different responder/non-responder subtypes.</p></li>
</ul>
<hr>
</section>
<section id="study-design" class="level3">
<h3 class="anchored" data-anchor-id="study-design">Study design</h3>
<ul>
<li><p>To learn this relationship, previous studies used “immortalized” cancer cell lines. These doesn’t fully represent the complexity of cancer in real populations.</p></li>
<li><p>The study <code>r Citep(bib, "Dietrich2017")</code> measured drug responses in samples from primary patients who were being treated for blood cancer (CLL). They simultaneously measured gene expression and DNA methylation activity (we will skip over some the biology, but happy to discuss this with anyone who’s interested).</p></li>
</ul>
<hr>
</section>
<section id="drug-response-data" class="level3">
<h3 class="anchored" data-anchor-id="drug-response-data">Drug response data</h3>
<p><em>Features</em> - 121 samples from CLL patients - 61 drugs, 5 dosages per drug - 9553 features total</p>
<p><em>Outcome</em> - Cell viability: Percentage of surviving cells after drug exposure</p>
<hr>
</section>
<section id="main-question" class="level3">
<h3 class="anchored" data-anchor-id="main-question">Main Question</h3>
<p><br> <br></p>
<p><strong>For a given drug treatment profile, which RNA or methylation features differentiate between drug sensitivity vs.&nbsp;resistance?</strong></p>
<hr>
</section>
<section id="review-code-example" class="level3">
<h3 class="anchored" data-anchor-id="review-code-example">Review Code Example</h3>
<ul>
<li><code>01-linear_model.qmd</code>: “Exploration”</li>
</ul>
<hr>
</section>
</section>
<section id="sparse-linear-regression" class="level2">
<h2 class="anchored" data-anchor-id="sparse-linear-regression">Sparse Linear Regression</h2>
<ul>
<li><p>Viability can be viewed as a <strong>response variable</strong> <span class="math inline">\(y \in \mathbb{R}^{N}\)</span>, and the molecular variables can be treated as <strong>features</strong> <span class="math inline">\(X \in \mathbb{R}^{N  \times J}\)</span>. Here</p></li>
<li><p>The setting is <strong>high-dimensional</strong> with few samples compared to features. Without some sort of regularization (like a sparsity assumption), the problem is underdetermined, since <span class="math inline">\(N = 121, J = 9553\)</span>.</p></li>
<li><p><strong>Sparsity</strong> will help us focus on the most important pathways out of thousands of candidates.</p></li>
</ul>
<p>This was a real study! Linear models are not just for class work…they are a practical tool in science.</p>
<hr>
<section id="single-continuous-predictor" class="level3">
<h3 class="anchored" data-anchor-id="single-continuous-predictor">Single continuous predictor</h3>
<p>Imagine modeling viability <span class="math inline">\(y_{i}\)</span>​ for sample <span class="math inline">\(i\)</span> as a linear function of a single gene’s expression level <span class="math inline">\(x_{i} \in \mathbb{R}\)</span>:</p>
<p><span class="math display">\[\begin{align*}
y_i=\beta_0+x_{i 1} \beta_1+\epsilon_i
\end{align*}\]</span></p>
<p>The least-squares estimate <span class="math inline">\(\hat{\beta} := \left(\hat{\beta}_{0}, \hat{\beta}_{1}\right)\)</span>​ is found by minimizing</p>
<p><span class="math display">\[\begin{align*}
\min_{\beta_0, \beta_1} \sum_{i = 1}^{N}\left(y_i-\beta_0-x_{i} \beta_1\right)^2
\end{align*}\]</span></p>
<hr>
</section>
<section id="visualization" class="level3">
<h3 class="anchored" data-anchor-id="visualization">Visualization</h3>
<hr>
</section>
<section id="single-categorical-predictor" class="level3">
<h3 class="anchored" data-anchor-id="single-categorical-predictor">Single categorical predictor</h3>
<p>That visualization considered <span class="math inline">\(x_{i}\)</span> to be continuous, but the same idea applies to categorical predictors. For example, <span class="math inline">\(x_{i} \in \{0, 1\}\)</span> could record whether the patient has a mutation in a particular gene.</p>
<ul>
<li><p><span class="math inline">\(\beta_0\)</span>​: The expected viability for the reference group (<span class="math inline">\(x_{i} = 0\)</span>).</p></li>
<li><p><span class="math inline">\(\beta_1\)</span>: The difference in expected viability between the mutated <span class="math inline">\(x_{i} = 1\)</span> and reference groups</p></li>
</ul>
<hr>
</section>
<section id="visualization-1" class="level3">
<h3 class="anchored" data-anchor-id="visualization-1">Visualization</h3>
<hr>
</section>
</section>
<section id="multiple-linear-regression" class="level2">
<h2 class="anchored" data-anchor-id="multiple-linear-regression">Multiple Linear Regression</h2>
<p>Assumed model form:</p>
<p><span class="math display">\[\begin{align*}
y_{i} &amp;= \sum_{j = 1}^{n}x_{ij}\beta_{j} + \epsilon_{i} \\
&amp;:= \mathbf{x}_{i}^\top \beta_{j} + \epsilon_{i}
\end{align*}\]</span></p>
<ul>
<li><p><span class="math inline">\(\epsilon_{i}\)</span> represents random variation due to unmeasured factors.</p></li>
<li><p>This model assumes the effect of feature <span class="math inline">\(j\)</span> on <span class="math inline">\(y\)</span> is constant regardless of the value of <span class="math inline">\(x_{k}\)</span> for any other feature <span class="math inline">\(k\)</span>.</p></li>
</ul>
<hr>
<section id="fitting-multiple-linear-regression" class="level3">
<h3 class="anchored" data-anchor-id="fitting-multiple-linear-regression">Fitting Multiple Linear Regression</h3>
<ul>
<li>We can estimate <span class="math inline">\(\hat{\beta} \in \mathbf{R}^{J}\)</span> by minimizing the residual sum of squares (RSS) loss,</li>
</ul>
<p><span class="math display">\[\begin{align*}
\min_{\beta} \sum_{i=1}^N \left( y_i - \mathbf{x}_i^\top \beta \right)^2
\end{align*}\]</span></p>
<hr>
</section>
<section id="visualization-two-continuous-predictors" class="level3">
<h3 class="anchored" data-anchor-id="visualization-two-continuous-predictors">Visualization: Two continuous predictors</h3>
<p>We can imagine how viability changes when changing the expression levels for two genes simultaneously.</p>
<hr>
</section>
<section id="visualization-one-continuous-one-categorical-predictor" class="level3">
<h3 class="anchored" data-anchor-id="visualization-one-continuous-one-categorical-predictor">Visualization: One continuous + one categorical predictor</h3>
<p>If we include a continuous pathway measurement and a binary mutation, the model generates one line per category, and the lines are parallel.</p>
<hr>
</section>
<section id="ceteris-paribus" class="level3">
<h3 class="anchored" data-anchor-id="ceteris-paribus">Ceteris paribus</h3>
<ul>
<li><p>“All other things being equal”.</p></li>
<li><p><span class="math inline">\(\beta_j\)</span>​ gives the impact of changing <span class="math inline">\(x_j\)</span> while every other feature <span class="math inline">\(k\)</span> in the model is fixed.</p></li>
<li><p>Warning: In our application, genes are often highly correlated. Holding other genes “fixed” is not realistic. This should be kept in mind whenever working with correlated features.</p></li>
</ul>
<hr>
</section>
<section id="interaction-terms" class="level3">
<h3 class="anchored" data-anchor-id="interaction-terms">Interaction terms</h3>
<ul>
<li><p>If we had <span class="math inline">\(J = 2\)</span>, we can consider two-way interactions,</p>
<p><span class="math display">\[\begin{align*}
  y_{i} = \beta_{0} + x_{1}\beta_{1} + x_{2}\beta_{2} + x_{1}x_{2}\beta_{3} + \epsilon_{i}
  \end{align*}\]</span></p>
<p>the coefficient <span class="math inline">\(\beta_{3}\)</span> represents the interaction.</p></li>
<li><p>The slope of for one gene now depends on the value of another (what does this mean algebraically?)</p></li>
<li><p>In our example, a gene might be important only for a particular drug.</p></li>
</ul>
<hr>
</section>
<section id="irrelevant-predictors" class="level3">
<h3 class="anchored" data-anchor-id="irrelevant-predictors">Irrelevant predictors?</h3>
<ul>
<li><p>If we had many noise features (unrelated to response), least squares will still try finding coefficients for each of them. This causes overfitting: our predictions would depend on variables that don’t actually matter.</p></li>
<li><p>We don’t expect all genes to be relevant to cell viability in this experiment. It’s more likely that a few key pathways are driving resistance.</p></li>
<li><p><strong>Variable selection</strong>: If the noise variables do not reduce the SSE, then the Lasso sets their coefficients <span class="math inline">\(\beta_{j}\)</span> to exactly zero. The <span class="math inline">\(\ell^{1}\)</span> penalty “induces sparsity.”</p></li>
</ul>
<hr>
</section>
</section>
<section id="ell1-regularization" class="level2">
<h2 class="anchored" data-anchor-id="ell1-regularization"><span class="math inline">\(\ell^{1}\)</span> Regularization</h2>
<p>The Lasso objective is <span class="math display">\[\begin{align*}
\min_{\beta \in \mathbb{R}^J} \left[ \frac{1}{2N} \sum_{i=1}^N \left(y_i - \mathbf{x}_i^\top \beta\right)^2 + \lambda \lVert \beta \rVert_1 \right].
\end{align*}\]</span> This is the same loss as linear regression, but with a new <span class="math inline">\(\ell^{1}\)</span> penalty</p>
<p><span class="math display">\[\begin{align*}
\|\beta\|_{1} := \sum_{j = 1}^{J} \left|\beta_{j}\right|
\end{align*}\]</span></p>
<hr>
</section>
<section id="ell1-regularization-1" class="level2">
<h2 class="anchored" data-anchor-id="ell1-regularization-1"><span class="math inline">\(\ell^{1}\)</span> Regularization</h2>
<p>It’s not obvious, but the minimizers often set coordinates <span class="math inline">\(\beta_{j}\)</span> to <em>exactly</em> zero. The “selected” features are those where <span class="math inline">\(\beta_{j} \neq 0\)</span>.</p>
<p><span class="math display">\[\begin{align*}
\min_{\beta \in \mathbb{R}^J} \left[ \frac{1}{2N} \sum_{i=1}^N \left(y_i - \mathbf{x}_i^\top \beta\right)^2 + \lambda \lVert \beta \rVert_1 \right].
\end{align*}\]</span></p>
<hr>
<section id="visualization-2" class="level3">
<h3 class="anchored" data-anchor-id="visualization-2">Visualization</h3>
<hr>
</section>
<section id="lasso-paths" class="level3">
<h3 class="anchored" data-anchor-id="lasso-paths">Lasso Paths</h3>
<ul>
<li><p><span class="math inline">\(\lambda\)</span> is a hyperparameter that controls model complexity.</p></li>
<li><p>As <span class="math inline">\(\lambda \uparrow \infty\)</span>, all coefficients shrink toward zero. As <span class="math inline">\(\lambda \downarrow 0\)</span>, we return to OLS.</p></li>
<li><p>We can study the “order” that variables enter the model as we gradually decrease <span class="math inline">\(\lambda\)</span>. We expect the most important predictors (e.g., drug response-related genes) to enter first.</p></li>
</ul>
<hr>
</section>
<section id="choosing-lambda" class="level3">
<h3 class="anchored" data-anchor-id="choosing-lambda">Choosing <span class="math inline">\(\lambda\)</span></h3>
<ul>
<li><p>What is an appropriate “budget” for model complexity?</p></li>
<li><p>Bias-Variance Trade-off: Decreasing <span class="math inline">\(\lambda\)</span> reduces bias but increases the variance of the predictions.</p></li>
<li><p>We need to tune <span class="math inline">\(\lambda\)</span> to balance these competing issues and achieve good performance on holdout samples.</p></li>
</ul>
<hr>
</section>
<section id="cross-validation" class="level3">
<h3 class="anchored" data-anchor-id="cross-validation">Cross-validation</h3>
<p>Split the data into <span class="math inline">\(K\)</span> folds (e.g., <span class="math inline">\(K = 5\)</span>). Fit the model on <span class="math inline">\(K−1\)</span> folds and tested on the remaining fold. This mimics the setting of gathering new data and testing the model on that data.</p>
<hr>
</section>
<section id="hyperparameter-selection" class="level3">
<h3 class="anchored" data-anchor-id="hyperparameter-selection">Hyperparameter Selection</h3>
<p>(show the glmnet curve)</p>
<ul>
<li><p><span class="math inline">\(\lambda_{\text{min}}\)</span>: Minimizes the cross-validation error.</p></li>
<li><p><span class="math inline">\(\lambda_{\text{1se}}\)</span>: The simplest model, i.e., largest <span class="math inline">\(\lambda\)</span>, whose error is within one standard error of the minimum. This is a sparser model with comparable performance to the best.</p></li>
</ul>
<hr>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>