---
title: Drug perturbation screens for blood cancer
author: kris sankaran
date: 2026-01-26
execute:
  cache: true
  warning: false
  message: false
---

Tumor cells from chronic lymphocytic leukemia (CLL) patients respond differently
to identical drugs. We predict drug sensitivity from molecular measurements
using regularized regression [[1](https://doi.org/10.1038/s41375-020-0846-5),
[2](https://arxiv.org/abs/1811.02962)]. The data are viability scores $y_i$ for
the drug Ibrutinib (small = cell death, large = survival) and features $X$
measuring molecular features (RNA expression, methylation, and sensitivity to
other drugs). By identifying which molecular patterns relate to drug
effectiveness, we can improve treatment targeting.

You can download the primary source data from
[this repository](https://git.embl.org/bvelten/graper_analyses/-/tree/master). We'll
work with a simplified version available
[here](https://zenodo.org/records/18371236).

# Setup

The block below includes libraries that we'll work with. We set a seed so that
cross-validation gives the same results each time.

```{r}
#| label: setup-libraries
library(fs)
library(ggforce)
library(glmnet)
library(scico)
library(tidyverse)
theme_set(theme_classic())
set.seed(20251223)
```

Let's read in the data.

```{r}
#| label: load-data
source("https://raw.githubusercontent.com/krisrs1128/stat479_notes/refs/heads/master/activities/01-helpers.R")

f <- tempfile()
download.file("https://zenodo.org/records/18371236/files/01-cll.rds?download=1", f)
cll_data <- readRDS(f)
```

The data has three parts. The response $y$ gives viability after Ibrutinib
treatment. Small values indicate the drug kills tumor cells, while large values
mean drug resistance. The predictors $X$ include three types of measurements:
RNA expression, methylation status, and sensitivity to other drugs.

```{r}
#| label: extract-xy
X <- cll_data$X
y <- cll_data$y
annotation <- tibble(
    variable = colnames(X),
    label = cll_data$annotation
)
```

We have $p = $ `r ncol(X)` features but only $n = $ `r nrow(X)` samples.

```{r}
#| label: count-types
count(annotation, label)
```

# Exploration

Before fitting models, we examine the data structure. First, how Ibrutinib
sensitivity relates to sensitivity to other drugs. Several drugs show similar
response patterns to Ibrutinib.

```{r}
#| label: plot-drug
xy <- bind_cols(viability = y, X)
plot_viability("drug", 1, 6, 5)
plot_viability("drug", 2, 6, 5)
```

The molecular features show weaker relationships. Some features correlate with
Ibrutinib sensitivity, but manually screening 9000+ features is unreasonable.
The scatterplots suggest linearity, making regularized linear regression
suitable.

```{r}
#| label: plot-molecular
plot_viability("RNA", 1, 6, 5)
plot_viability("methylation", 1, 6, 5)
```

# Sparse Regression

The lasso minimizes
\begin{align*}
\min_{\beta \in \mathbf{R}^J} \left[ \frac{1}{2N} \sum_{i=1}^N \left(y_i - \mathbf{x}_i^\top \beta\right)^2 + \lambda \lVert \beta \rVert_1 \right].
\end{align*}
where $\lambda$ controls sparsity. We fit using `glmnet` with `alpha = 1` for
the $\ell^1$ penalty.

```{r}
#| label: fit-lasso
# fit <- ...
```

The plot shows cross-validation error across $\lambda$ values (decreasing left
to right). Labels at top indicate the number of selected features. The vertical
lines mark $\lambda_{\text{min}}$ (minimum CV error) and $\lambda_{\text{1se}}$
(most regularized model within one standard error).

Next we compare true and predicted viability scores. The model underestimates
large $y_i$ and overestimates low $y_i$, suggesting underfitting. Overall
correlation is good.

```{r}
#| label: plot-predictions
# ???
```

Extract coefficients at $\lambda_{\text{1se}}$ using `coef`:

```{r}
#| label: coef-head
head(coef(fit))
```

Nonzero coefficients at $\lambda_{\text{1se}}$:

```{r}
#| label: plot-coef
plot_coef(fit, s = "lambda.1se")
```

# Standardization

`glmnet` standardizes features by default. Without standardization, the penalty
$\lambda \sum_j |\beta_j|$ depends on feature scales.  Compare predictions
without standardization:

```{r}
#| label: no-standardize
fit_no_standard <- cv.glmnet(X, y, standardize = FALSE)
plot_predictions(fit_no_standard, X, y)
```

The predictions get worse.

# Coefficient Trajectories

Which features have the largest $\beta_j(\lambda)$ across the regularization
path? The default plot shows this.

```{r}
#| label: plot-paths
# ???
```

Each line represents one feature's coefficient as $\lambda$ decreases. The plot
doesn't identify which feature corresponds to which line. We could inspect
coefficients.

```{r}
#| label: coef-matrix
coef(fit$glmnet.fit)[1:4, 1:5]
```

Alternatively, a heatmap helps.

```{r}
#| label: plot-heatmap
beta_hat_lambda <- annotated_beta(coef(fit$glmnet.fit), annotation)
tile_plot(beta_hat_lambda)
```

# Raw Data Check

Verify that selected features show genuine linear relationships, not artifacts
from outliers or leverage points. Caution: correlation among features means
important features might have understimated $\beta$.

```{r}
#| label: check-raw
plot_viability("drug", 1, 5, 4, beta_hat_lambda$variable)
plot_viability("RNA", 1, 3, 3, beta_hat_lambda$variable)
plot_viability("methylation", 1, 3, 3, beta_hat_lambda$variable)
```

The selected features show associations with viability. We can validate findings
with existing databases,

- https://useast.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000019102;r=11:124747472-124752255
- https://www.proteinatlas.org/ENSG00000019102-VSIG2/cancer
